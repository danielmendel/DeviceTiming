/**
 * JavaScript code for visualization page
 * See individual function level comments for details
 *
 * TODO: Can be uglified by Node before serving.
 * @author    Joseph Khan <jkhan@yodlee.com>
 *
 **/
(function() {
	//Feature Detection - using querySelector
	if(!(document.querySelector || ('querySelector' in document))) {
		alert('You have an old browser. Kindly check in a new browser');
		return;
	}
	//Local Variables
	var reportData = {},
		popUpOpen = false,
		userAgentArr = [],  //stores the user agent strings
		detectionArr = [],  //stores the detected client \ browser details
		scriptFileArr = [], //stores the javascript file names
		chartInstanceArr = [],
		colorArr = ['#B64926', '#ED8C2B', '#225378', '#1695A3'];

	//DOM Reference Variables
	var	scriptList = document.querySelector("#scriptFileList"),
		browserList = document.querySelector("#browserList"),
		toggleButtonCollection = document.querySelectorAll(".btn-toggle-expand"),
		mappingLink = document.querySelector("#mappingLink"),
		mappingPopUp = document.querySelector("#mappingPopUp");

	//Event Registrations
	scriptList.addEventListener('change', handleScriptChange, false);
	browserList.addEventListener('change', handleBrowserChange, false);
	for(var i =0; i < toggleButtonCollection.length; i++) {
		toggleButtonCollection[i].addEventListener('click', toggleWidgetContent, false);
	}
	mappingLink.addEventListener('click', handleMappingLinkClick, false);

	//Event Handler functions
	function handleScriptChange() {
		getParseAndExecTimeForScript(this.options[this.selectedIndex].value);
	}

	function handleBrowserChange() {
		getParseAndExecTimeForBrowser(this.options[this.selectedIndex].value);
	}

	function toggleWidgetContent(evt) {
		var toggleButtonImg = evt.currentTarget.firstChild,
			widgetContent = evt.currentTarget.parentNode.parentNode.nextSibling;//document.querySelector("#content-chart1");

		if(toggleButtonImg.src.search("up") > 0) {
			collapse(widgetContent);
			toggleButtonImg.src = "down.svg";
		} else {
			toggleButtonImg.src = "up.svg";
			expand(widgetContent);
		}
		evt.preventDefault();
		return false;
	}
	function handleMappingLinkClick(evt) {
		if(!popUpOpen) {
			mappingPopUp.style.display = "block";
			popUpOpen = true;
		} else {
			mappingPopUp.style.display = "none";
			popUpOpen = false;
		}
		evt.preventDefault();
		return false;
	}
	//END of Event Handler functions

	//collapse, expand - separate functions for future enhancements
	function collapse(container) {
		container.style.display = "none";
	}
	function expand(container) {
		container.style.display = "block";
	}

	//sends an Ajax request for report json data
	//report json generated by the "report" command
	function sendAjaxReq(url) {
		var req = new XMLHttpRequest();
		req.open("GET", url, true);
		req.onreadystatechange = function() {
			if(req.status === 200 && req.readyState === 4) {
				reportData = JSON.parse(req.response);
				//console.log(reportData);

				getAllScriptFileNames(); //for select list
				getAlluserAgentNames(); //for select list

				chartInstanceArr.push(createChart('#combo_chart', '', '', 0, colorArr[0], colorArr[1]));   //create the barebones of chart1 and keep it ready
				chartInstanceArr.push(createChart('#another_chart', '', '', 0, colorArr[2], colorArr[3]));   //create the barebones of chart2 and keep it ready

				getParseAndExecTimeForScript(scriptFileArr[0]);
				getParseAndExecTimeForBrowser(userAgentArr[0]);

				generateMappingTable();
			}
		};
		req.send();
	}
	//reads all the javascript file names from the report data
	function getAllScriptFileNames() {
		for(var ua in reportData) {
			for(var key in reportData[ua].times) {
				var newOption = document.createElement('option');
				newOption.text = key.slice(1, key.length);
				scriptFileArr.push(key.slice(1, key.length));
				scriptList.add(newOption);
			}
			return;  //return after one  iteration of the outer loop
		}
	}
	//reads all the browser user agent and detected client\browser names from report data
	function getAlluserAgentNames() {
		for(var ua in reportData) {
			var newOption = document.createElement('option');
			userAgentArr.push(ua);
			detectionArr.push(reportData[ua].detect);
			newOption.text = reportData[ua].detect;
			newOption.value = ua;
			browserList.add(newOption);
		}
	}

	//reads the parse and execution time upon passing a javascript file name
	//refreshes the chart component with the new data
	function getParseAndExecTimeForScript(scriptFileName) {
		var parseArr = [], execArr = [], _scriptObj;
		for(var ua in reportData) {
			_scriptObj = reportData[ua].times["/" + scriptFileName];
			//console.log(_scriptObj.parse + "/" + _scriptObj.exec);
			parseArr.push(_scriptObj.parse);
			execArr.push(_scriptObj.exec);
		}
		reloadChartData(chartInstanceArr[0], parseArr, execArr, false);
	}

	//reads the parse and execution time upon passing a browser user agent name
	//refreshes the chart component with the new data
	function getParseAndExecTimeForBrowser(userAgentName) {
		var parseArr = [], execArr = [];
		for(var scriptFile in reportData[userAgentName].times) {
			//console.log('----' , reportData[userAgentName].times[scriptFile]);
			parseArr.push(reportData[userAgentName].times[scriptFile].parse);
			execArr.push(reportData[userAgentName].times[scriptFile].exec);
		}
		reloadChartData(chartInstanceArr[1], parseArr, execArr, true);
	}

	//Maps the user agent string to its corresponding detected client|browser match
	//Takes userAgentArr and detectionArr and generates an HTML table for the mapping
	function generateMappingTable() {
		var tableRows = "",
			tableBody = null;

		tableBody = document.querySelector("#mappingTable tbody");
		for(var i =0; i < userAgentArr.length; i++) {
			tableRows += "<tr><td>" + detectionArr[i] + "</td><td>" + userAgentArr[i] + "</td></tr>";
		}

		tableBody.innerHTML = tableRows;
	}

	/*
	** Primary function for creating the column chart component
	** @params
	** bindingContainer: container element within which the chart is rendered
	** xLabel: label text for x -axis
	** yLabel: label text for y -axis
	** tickRotateAngle: rotation angle for x- axis ticks
	** color1: fill color value for column1
	** color2: fill color value for column2
	*/
	function createChart(bindingContainer, xLabel, yLabel, tickRotateAngle, color1, color2) {
		return c3.generate({
	    	bindto: bindingContainer,
	    	/*size: {
		        height: 400
		    },*/
		    data: {
		        x : 'x',
		        /*groups: [
		            ['parse', 'execution']    //for stacked chart enable this
		        ],*/
		        json: {},
		        type: 'bar',
		        labels: true,
		        colors: {
		            parse: color1,
		            execution: color2
		        }
		    },
		    /*zoom: {
		        enabled: true
		    },*/
		    grid: {
		        /*x: {
		            show: true
		        }*/
		        y: {
		        	show: true
		        }
		    },
		    legend: {
		        position: 'right'
		    },
		    tooltip: {
		        grouped: false // Default true
		    },
		    axis: {
		    	//rotated: true,
		        x: {
		        	label: {
		        		text: xLabel,
		        		position: 'outer-center'
		                // inner-right : default
		                // inner-center
		                // inner-left
		                // outer-right
		                // outer-center
		                // outer-left
		        	},
		            type: 'category', // this needed to load string x value
		            tick: {
		                rotate: tickRotateAngle,
		                culling: { max: 5 }
		            }
		            //height: 200
		        },
		        y: {
		            label: {
		                text: yLabel,
		                position: 'outer-middle'
		                // inner-top : default
		                // inner-middle
		                // inner-bottom
		                // outer-top
		                // outer-middle
		                // outer-bottom
		            },
		            padding: {top: 10, bottom: 0},
		            tick: {
			          format: function(d) {
			          	return d + " ms";
			          }
			        }
		        }
		    }
		});
	}

	/*
	** Refreshes the chart component with new data
	** @params
	** chartInstance: chart object or instance
	** parseArr: array with all the parse times
	** execArr: array with all the execution times
	** scriptOrBrowser: boolean value that decides if the x- axis category type should be script file or browser based
	**
	*/
	function reloadChartData(chartInstance, parseArr, execArr, scriptOrBrowser) {
		chartInstance.load({
			json: {
		        	x: (scriptOrBrowser) ? scriptFileArr : detectionArr,
		        	parse: parseArr,
		        	execution: execArr
	        }
    	});
	}

	//starting point
	sendAjaxReq("report.json");   //send request for report json and start rendering
})();
